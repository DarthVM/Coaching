# Теоретическая часть
## Виды библиотек

# Сборка и подключение динамической библиотеки (DLL) в C++ с использованием CMake
## Компилятор MSVC (Visual Studio). [Ссылка на скачку тут](https://visualstudio.microsoft.com/visual-cpp-build-tools/)

### Сборка
Для сборки .dll библиотеки под Windows на MSVC необходимо указывать экспортируемые функции с помощью атрибута __declspec (declaration specifier):
``` cpp
// my_library.h

__declspec(dllexport)
double add_numbers(double a, double b);

...

//


// my_library.cpp

double add_numbers(double a, double b) {
    return a + b;
}

...

//
```

Объявив (declare) функцию в header-файле (заголовочном файле, .h) и определив (define) в исходном файле (.cpp) нужно скомпилировать библиотеку. Для автоматизированной сборки используем инструмент сборки проектов CMake.

В директории проекта создадим ```CMakeLists.txt```:
```cmake
# Минимальня требуемя версия CMake
CMAKE_MINIMUM_REQUIRED(VERSION 3.20) 

# Название проекта
project(MyLib) 

# Объявим переменную, где расположен исходный файл библиотеки
set(my_library_cpp /path/to/cpp) 

# Создаем библиотеку с названием my_library типа SHARED (т. е. .dll)
add_library(my_library SHARED ${my_library_cpp}) 

```
Запускаем сборку - в терминале, по пути директории проекта вводим команды.
``` powershell
# Создание папки для файлов сборки
mkdir build 

cd build

# Генерация файлов для сборки с генератором MSVC и типа Release (для создания с возможностью отладки - использовать "Debug")
cmake -G "Visual Studio 17 2022" -DCMAKE_BUILD_TYPE=Release .. 

# Заупск компиляции с помощью makefile
cmake --build . --config Release 
```
Теперь, в директории ```build/Release``` содержатся файлы созданной библиотеки с расширением .dll и .lib. Их можно переместить в любую удобную папку в системе


### Подключение
#### Неявное подключение (ранее связывание)
Для подключения библиотеки в любом другом проекте нужно обозначить, что определение (тело) функции импортируется из .dll файла и что такая функция с такой-то сигнатурой существует:
```cpp
// my_library.h

__declspec(dllimport)
double add_numbers(double a, double b);
...

//
```

Теперь можно вызвать функцию просто включив header-файл:
```cpp
// main.cpp

#include "my_library.h"

#include <iostream>

int main() {
    double x = 5.7;
    double y = 3.1;

    double result = add_numbers(x, y);

    std::cout << result << std::endl;

    return 0;
}

//
```

В директории проекта создадим ```CMakeLists.txt```:
```cmake
CMAKE_MINIMUM_REQUIRED(VERSION 3.20) 

project(MyTest) 

# Объяснить компилятору, в какой директории лежат .lib файлы 
link_directories(path/to/lib) 

# Исходные файлы, которые нужно скомпилировать для получения исполняемого файла 
add_executable(${CMAKE_PROJECT_NAME} src/main.cpp) 

# говорим комиплятору названия библиотек, которые надо подключить к нашему проекту
target_link_libraries(${CMAKE_PROJECT_NAME} my_library)

# Копируем dll файлы в директорию с .exe, чтобы программа смогла найти файлы и обратиться к функциям
add_custom_command(TARGET ${CMAKE_PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
        "path/to/dll_directory"
        $<TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}>)
```

Вводим те же команды:
```powershell
mkdir build
cd build
cmake -G "Visual Studio 17 2022" -DCMAKE_BUILD_TYPE=Release ..
cmake --build . --config Release
```
Теперь запускаем исполняемый файл (.exe) программы (проекта)

#### Явное подключение (позднее связывание)

Помимо подключения библиотеки на этапе компиляции и запуска программы с dll, можно подключить библиотеку прямо в коде без .lib файлов. 

Суть состоит в вызове функции посредством API операционной системы Windows.

```cpp
#include "Windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(REAL8,REAL8);

HRESULT call_add_numbers(REAL8 param1, REAL8 param2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("my_library"); // путь к dll
    if (hDLL != NULL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "add_numbers");
        if (lpfnDllFunc1 != NULL)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(param1, param2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}

int main() { 
    double x = 5.7;
    double y = 3.1;

    double result = call_add_numbers(x, y);

    std::cout << result << std::endl;

    return 0;
}
```
Только такой метод сложнее, так как нужно использовать в качестве типов данных [директивы для ассмеблера](https://learn.microsoft.com/ru-ru/cpp/assembler/masm/directives-reference?view=msvc-170)


## Компилятор MinGW. [Ссылка на скачку тут](https://cygwin.com/install.html#:~:text=Installing%20and%20Updating%20Cygwin%20for%2064%2Dbit%20versions%20of%20Windows)
### Особенности
* MinGW (GCC) формирует не .lib, а .dll.a, т. е. архивированную статическую библиотеку для UNIX-систем. Но разницы в подключении нет, можно считать файлы такого типа как статическую билиотеку для Windows.
* При сборке, указывать генератор MinGW или Ninja:
```powershell
cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
```