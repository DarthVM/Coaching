# Теоретическая часть


## Виды библиотек
Разделяют две виды библиотеки:
* статическую (static, archive)
* динамическую (shared, dynamic)

На практике: 
* в Unix - это ```.a``` и ```.so```
* в Windows - это ```.lib``` и ```.dll```

____________________________

# Сборка и подключение динамической библиотеки (DLL) в C++ с использованием CMake. [Ссылка на скачку тут](https://github.com/Kitware/CMake/releases/download/v4.1.0/cmake-4.1.0-windows-x86_64.msi)

## Компилятор MSVC (Visual Studio). [Ссылка на скачку тут](https://visualstudio.microsoft.com/visual-cpp-build-tools/)

### Сборка

_______

Для сборки .dll библиотеки под Windows на MSVC необходимо указывать экспортируемые функции с помощью атрибута ```__declspec``` (declaration specifier):

``` cpp
// my_library.h

__declspec(dllexport)
double add_numbers(double a, double b);

...

//


// my_library.cpp

double add_numbers(double a, double b) {
    return a + b;
}

...

//
```

Объявив (declare) функцию в header-файле (заголовочном файле, ```.h```) и определив (define) в исходном файле (```.cpp```) нужно скомпилировать библиотеку. Для автоматизированной сборки используем инструмент сборки проектов CMake.

В директории проекта создадим ```CMakeLists.txt```:

``` cmake
# Минимальня требуемя версия CMake
CMAKE_MINIMUM_REQUIRED(VERSION 3.20) 

# Название проекта
project(MyLib) 

# Объявим переменную, где расположен исходный файл библиотеки
set(my_library_cpp /path/to/cpp) 

# Создаем библиотеку с названием my_library типа SHARED (т. е. .dll)
add_library(my_library SHARED ${my_library_cpp}) 

```
Запускаем сборку - в терминале, по пути директории проекта вводим команды.

``` powershell
# Создание папки для файлов сборки
mkdir build 

cd build

# Генерация файлов для сборки с генератором MSVC и типа Release (для создания с возможностью отладки - использовать "Debug")
cmake -G "Visual Studio 17 2022" -DCMAKE_BUILD_TYPE=Release .. 

# Заупск компиляции с помощью makefile (использовать и для повторной компиляции)
cmake --build . --config Release 
```

Теперь, в директории ```build/Release``` содержатся файлы созданной библиотеки с расширением ```.dll``` и ```.lib```. Их можно переместить в любую удобную папку в системе. Если выбран вариант Debug, то нужен всегда и ```.pdb``` файл

Здесь ```.lib``` - это не статическая библиотека, в Windows  - это также файл библиотеки импорта при создание .dll библиотеки, в остальных случаях - статическая билиотека. В контексте ```.dll```, ```.lib``` содержит инструкции для подключения самой ```.dll``` бибилотеки во время исполнения программы. Это исключает нужду подключать библиотеку в самом коде в явном виде ([раздел "Явное подключение"](#явное-подключение-(позднее-связывание))).

________

### Подключение

______

#### Неявное подключение (ранее связывание)
Для подключения библиотеки в любом другом проекте нужно обозначить, что определение (тело) функции импортируется из ```.dll``` файла и что такая функция с такой-то сигнатурой существует:
```cpp
// my_library.h

__declspec(dllimport)
double add_numbers(double a, double b);
...

//
```

Теперь можно вызвать функцию просто включив header-файл:

``` cpp
// main.cpp

#include "my_library.h"

#include <iostream>

int main() {
    double x = 5.7;
    double y = 3.1;

    double result = add_numbers(x, y);

    std::cout << result << std::endl;

    return 0;
}

//
```

В директории проекта создадим ```CMakeLists.txt```:

``` cmake
CMAKE_MINIMUM_REQUIRED(VERSION 3.20) 

# Название проекта и нашей програаммы
project(MyTest) 

# Объяснить компилятору, в какой директории лежат .lib файлы 
link_directories(path/to/lib) 

# Исходные файлы, которые нужно скомпилировать для получения исполняемого файла 
add_executable(${CMAKE_PROJECT_NAME} src/main.cpp) 

# говорим комиплятору названия библиотек, которые надо подключить к нашему проекту
target_link_libraries(${CMAKE_PROJECT_NAME} my_library)

# Копируем dll файлы в директорию с .exe, чтобы программа смогла найти файлы и обратиться к функциям
add_custom_command(TARGET ${CMAKE_PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
        "path/to/dll_directory"
        $<TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}>)
```

Вводим те же команды:
``` powershell
mkdir build
cd build
cmake -G "Visual Studio 17 2022" -DCMAKE_BUILD_TYPE=Release ..
cmake --build . --config Release
```
Теперь запускаем исполняемый файл (.exe) программы (проекта)

НО. Процесс можно облегчить. Чтобы не копировать header-файл библиотеки каждый раз и менять его, а взять какой-то общий header-файл и использовать его и для экспорта и импорта, то: 

1. В файле ```my_library.h```, который был для экспорта в самом начале добавляем директивы препроцессора:
``` cpp
// Если переменная _EXPORTING определена, то экспортируем функцию, нет - импортируем
#ifdef _EXPORTING
   #define DLL_FUNC    __declspec(dllexport)
#else
   #define DLL_FUNC    __declspec(dllimport)
#endif
```
2. Теперь к каждой функции до типа данных добавляем ```DLL_FUNC```:

``` cpp
DLL_FUNC double add_numbers(double a, double b);
```

3. При экспорте, в конце ```CMakeLists.txt``` добавляем:

``` cmake
# Определяем макрос 
target_compile_definitions(${CMAKE_PROJECT_NAME} _EXPORTING=1)
# Теперь компилятору определили макрос => у нас dllexport
```

4. Вернемся к подключению: можно просто скопировать файл, чтобы сэкономить время, указать полный путь или другие 146 варианта. 

_____
#### Явное подключение (позднее связывание)

Помимо подключения библиотеки на этапе компиляции с файлами библиотеки импорта и запуска программы с ```.dll```, можно подключить библиотеку прямо в коде без ```.lib``` файлов. 

Суть состоит в вызове функции посредством API операционной системы.

``` cpp
#include "Windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(REAL8,REAL8);

HRESULT call_add_numbers(REAL8 param1, REAL8 param2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("my_library"); // путь к dll
    if (hDLL != NULL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "add_numbers");
        if (lpfnDllFunc1 != NULL)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(param1, param2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}

int main() { 
    double x = 5.7;
    double y = 3.1;

    double result = call_add_numbers(x, y);

    std::cout << result << std::endl;

    return 0;
}
```
Только такой метод сложнее, так как нужно использовать в качестве типов данных [директивы для ассмеблера](https://learn.microsoft.com/ru-ru/cpp/assembler/masm/directives-reference?view=msvc-170)

______

## Компилятор MinGW. [Ссылка на скачку тут]()
### Особенности
* MinGW (GCC) формирует не .lib, а .dll.a, т. е. архивированный файл библиотеки импорта, но разница в подключении нет и можно считать аналогом.
* При сборке, указывать генератор MinGW или Ninja:
``` powershell
cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
```

## Linux
